## TCP client/server sample
# 执行如下步骤的一个回射服务器
    1. 客户从*标准输入*输入一行并写给服务器
    2. 服务器从*网络输入*读入这行文本并回射给客户
    3. 客户从*网络输入*读入这行回射文本并显示在*标准输出*

*对errno == EINTR的理解*
    1. 发生于系统调用，阻塞于系统调用时捕获到信号，导致系统无法自行返回改系统调用，故需手动goto重新使用，*没有真正的错误发生*
        2. 遇到时应该重新执行该系统调用 

# POSIX信号处理(注意:读完APUE后返回再看)
1. *信号就是某个进程发生了某个事件的通知，有时也成为软件中断*
    1. 信号可以由进程发送给进程
    2. 也可以由内核发送给进程
2. 每个信号都有一个对应的处置（disposition），也称为行为（action），通过调用sigaction函数来捕获（catching）信号



# SIGCHLD信号

是子进程传递给父进程的信号（子进程成为僵0

死进程后发送给父进程）

1. 父进程在捕获sigchld之后一般会调用wait或waitpid来处理

2. waitpid比wait有更灵活的操作（wait是对waitpid的封装）

3. <u>当fork子程序时，必须捕获SIGCHLD信号</u>

4. 使用waitpid避免留下僵死进程

   **如果多个实例同时结**束（几乎同时发出多个SIGCHLD），wait无法清除所有的子进程**

5. 捕获信号时必须处理被中断的系统调用

# 关于accept返回前连接中止

服务端在socket bind listen后睡眠,此时客户发送connect请求,客户会发送一个RST包,而处理方式依赖于系统的实现



# 服务器进程终止

如果服务器单方面kill掉了服务进程,将会出现以下情况(*注意:与崩溃不同*)

1. 服务器向客户发送一个FIN,客户则响应一个ACK
2. SIGCHLD信号被发送给服务进程的父进程并被处理
3. 客户阻塞在fgets上,并无发生其他事
4. 再次通过tcp发送数据时,由于目标socket已经关闭,服务器响应一个RST



# SIGPIPE信号

假如客户不理会系统调用返回的错误,反而写入更多的数据到服务器上时:

*如在读回数据之前执行两次针对服务器的写操作,而RST是针对第一次写引发的*

1. 当进程向某个已经收到RST的套接字写时,内核向进程发送一个SIGPIPE信号,默认行为是终止进程
2. 无论进程处理还是忽略了该信号,写操作都会返回EPIPE错误

# 服务器主机崩溃后

1. 服务器主机已崩溃,对客户无任何响应,则返回的错误是ETIMEOUT

2. 某个中间路由器判定主机不可达,响应一个destination unreachable的ICMP消息,则返回的错误是EHOSTUNREACH或ENETUNREACH
3. *以上讨论的情形是我们向服务器主机发送数据后才能检测出的错误*

